# -*- coding: utf-8 -*-
"""streamlitt

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Z99SO7VhKpN0IdaAJ5FL2J7m44PDkFc5
"""

import streamlit as st
import pandas as pd
import plotly.express as px
from azure.storage.blob import BlobServiceClient
from io import BytesIO

# Azure Blob Storage config
ACCOUNT_URL = "https://iesstsabdbaa.blob.core.windows.net/"
CONTAINER_NAME = "group7"
RIDE_PATH = "optimized_ride_data"
DRIVER_PATH = "optimized_driver_data"
ACCESS_KEY = "yfqMW8gf8u+M5pOW33Q5gtRTFBJQXStVK4K2rlCVVzxlrRG21Sh7MVj06uExoL86Npb7HWWgxYUe+ASthUr6/g=="

# Connect to Azure Blob Storage
blob_service_client = BlobServiceClient(account_url=ACCOUNT_URL, credential=ACCESS_KEY)

def load_parquet_from_blob(path_prefix):
    container_client = blob_service_client.get_container_client(CONTAINER_NAME)
    blob_list = container_client.list_blobs(name_starts_with=path_prefix)
    dataframes = []
    for blob in blob_list:
        blob_client = container_client.get_blob_client(blob.name)
        stream = BytesIO(blob_client.download_blob().readall())
        try:
            df = pd.read_parquet(stream)
            dataframes.append(df)
        except Exception:
            continue
    if dataframes:
        return pd.concat(dataframes, ignore_index=True)
    return pd.DataFrame()

# Streamlit page setup
st.set_page_config(page_title="ðŸš– Real-Time Ride & Driver Dashboard", layout="wide")
st.title("ðŸš¦ Real-Time Ride & Driver Dashboard")

# Load data
ride_df = load_parquet_from_blob(RIDE_PATH)
driver_df = load_parquet_from_blob(DRIVER_PATH)

# Preprocessing
if "datetime" in ride_df.columns:
    ride_df["datetime"] = pd.to_datetime(ride_df["datetime"])
if "pickup_time" in ride_df.columns and "dropoff_time" in ride_df.columns:
    ride_df["pickup_time"] = pd.to_datetime(ride_df["pickup_time"])
    ride_df["dropoff_time"] = pd.to_datetime(ride_df["dropoff_time"])
    ride_df["ride_duration_min"] = (ride_df["dropoff_time"] - ride_df["pickup_time"]).dt.total_seconds() / 60

# ================= BASIC ANALYTICS ====================
if not ride_df.empty:
    st.header("ðŸ“Š Basic Analytics")

    col1, col2, col3 = st.columns(3)
    col1.metric("Total Rides", len(ride_df))
    col2.metric("Completed Rides", len(ride_df[ride_df["status"] == "completed"]))
    col3.metric("Active Drivers", len(driver_df[driver_df["status"] == "active"]))

    st.subheader("Ride Status Distribution")
    status_fig = px.pie(ride_df["status"].value_counts().reset_index(),
                        names="index", values="status", title="Ride Status")
    st.plotly_chart(status_fig, use_container_width=True)

    st.subheader("Ride Duration Distribution (mins)")
    dur_fig = px.histogram(ride_df, x="ride_duration_min", nbins=30)
    st.plotly_chart(dur_fig, use_container_width=True)

    st.subheader("Rides Over Time")
    rides_time = ride_df.set_index("datetime").resample("H").size().rename("ride_count").reset_index()
    time_fig = px.line(rides_time, x="datetime", y="ride_count")
    st.plotly_chart(time_fig, use_container_width=True)

# ================= INTERMEDIATE ANALYTICS ====================
    st.header("ðŸ§® Intermediate Analytics")

    # Cancellation Rate
    cancel_rate = len(ride_df[ride_df["status"] == "cancelled"]) / len(ride_df) * 100
    st.metric("Cancellation Rate", f"{cancel_rate:.2f}%")

    # Demand vs. Supply Matching
    demand = ride_df.set_index("datetime").resample("H").size().rename("ride_requests")
    supply = driver_df[driver_df["status"] == "active"]
    demand_supply = demand.reset_index()
    demand_supply["active_drivers"] = len(supply)  # optional: make dynamic by hour if available
    fig_demand_supply = px.line(demand_supply, x="datetime", y=["ride_requests", "active_drivers"],
                                 title="Demand vs. Supply Over Time")
    st.plotly_chart(fig_demand_supply, use_container_width=True)

# ================= ADVANCED ANALYTICS PLACEHOLDER ====================
    st.header("ðŸ§  Advanced Analytics (Planned)")

    st.info("Coming soon: Real-time anomaly detection, surge pricing prediction, fraud detection...")

# ================= DRIVER ANALYTICS ====================
if not driver_df.empty:
    st.header("ðŸš˜ Driver Analytics")

    st.subheader("Driver Status")
    driver_status_fig = px.pie(driver_df["status"].value_counts().reset_index(),
                               names="index", values="status", title="Driver Status")
    st.plotly_chart(driver_status_fig, use_container_width=True)

    st.subheader("Vehicle Types")
    vehicle_fig = px.bar(driver_df["vehicle_type"].value_counts().reset_index(),
                         x="index", y="vehicle_type", title="Vehicle Type Distribution",
                         labels={"index": "Vehicle Type", "vehicle_type": "Count"})
    st.plotly_chart(vehicle_fig, use_container_width=True)