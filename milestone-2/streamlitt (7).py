# -*- coding: utf-8 -*-
"""streamlitt

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Z99SO7VhKpN0IdaAJ5FL2J7m44PDkFc5
"""

import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from azure.storage.blob import BlobServiceClient
from io import BytesIO
from datetime import datetime
import numpy as np

# ----------------- FRAUD DETECTION CLASS -----------------
class FraudDetection:
    def __init__(self):
        self.ride_requests = pd.DataFrame(columns=[
            'request_id', 'passenger_id', 'pickup_lat', 'pickup_lng',
            'destination_lat', 'destination_lng', 'ride_type', 'status',
            'estimate_price', 'demand_level', 'estimated_distance_km', 'datetime'
        ])
        self.driver_statuses = pd.DataFrame(columns=[
            'driver_id', 'current_lat', 'current_lng', 'status', 'vehicle_type', 'timestamp'
        ])
        self.passenger_stats = pd.DataFrame(columns=[
            'passenger_id', 'total_rides', 'cancellation_rate', 'avg_speed_kmh', 'last_active'
        ])
        self.driver_stats = pd.DataFrame(columns=[
            'driver_id', 'status_changes', 'availability_rate', 'avg_trip_length', 'vehicle_consistency'
        ])
        self.fraud_thresholds = {
            'passenger_cancellation': 0.4,
            'passenger_speed': 120,
            'driver_status_changes': 10,
            'price_deviation': 2.5
        }

    def add_ride_request(self, request_data):
        new_row = pd.DataFrame([request_data])
        self.ride_requests = pd.concat([self.ride_requests, new_row], ignore_index=True)
        self._update_passenger_stats(request_data['passenger_id'])

    def add_driver_status(self, status_data):
        new_row = pd.DataFrame([status_data])
        self.driver_statuses = pd.concat([self.driver_statuses, new_row], ignore_index=True)
        self._update_driver_stats(status_data['driver_id'])

    def _update_passenger_stats(self, passenger_id):
        rides = self.ride_requests[self.ride_requests['passenger_id'] == passenger_id]
        if len(rides) > 0:
            total_rides = len(rides)
            cancellation_rate = len(rides[rides['status'] == 'cancelled']) / total_rides
            avg_speed = self._calculate_passenger_speed(rides)
            stats = {
                'passenger_id': passenger_id,
                'total_rides': total_rides,
                'cancellation_rate': cancellation_rate,
                'avg_speed_kmh': avg_speed,
                'last_active': datetime.now()
            }
            if passenger_id in self.passenger_stats['passenger_id'].values:
                self.passenger_stats.loc[self.passenger_stats['passenger_id'] == passenger_id] = pd.DataFrame([stats])
            else:
                self.passenger_stats = pd.concat([self.passenger_stats, pd.DataFrame([stats])], ignore_index=True)

    def _calculate_passenger_speed(self, rides):
        if len(rides) < 2: return 0
        rides = rides.sort_values('datetime')
        speeds = []
        for i in range(1, len(rides)):
            prev, curr = rides.iloc[i-1], rides.iloc[i]
            try:
                time_diff = (pd.to_datetime(curr['datetime']) - pd.to_datetime(prev['datetime'])).total_seconds() / 3600
                if time_diff > 0:
                    distance = self._haversine_distance(prev['destination_lng'], prev['destination_lat'],
                                                        curr['pickup_lng'], curr['pickup_lat'])
                    speeds.append(distance / time_diff)
            except: continue
        return np.mean(speeds) if speeds else 0

    def _update_driver_stats(self, driver_id):
        entries = self.driver_statuses[self.driver_statuses['driver_id'] == driver_id]
        if len(entries) > 0:
            status_changes = len(entries) - 1
            availability_rate = len(entries[entries['status'] == 'available']) / len(entries)
            vehicle_types = entries['vehicle_type'].unique()
            vehicle_consistency = 1 if len(vehicle_types) == 1 else 0
            stats = {
                'driver_id': driver_id,
                'status_changes': status_changes,
                'availability_rate': availability_rate,
                'avg_trip_length': 0,
                'vehicle_consistency': vehicle_consistency
            }
            if driver_id in self.driver_stats['driver_id'].values:
                self.driver_stats.loc[self.driver_stats['driver_id'] == driver_id] = pd.DataFrame([stats])
            else:
                self.driver_stats = pd.concat([self.driver_stats, pd.DataFrame([stats])], ignore_index=True)

    def _haversine_distance(self, lon1, lat1, lon2, lat2):
        R = 6371
        dLat = np.radians(lat2 - lat1)
        dLon = np.radians(lon2 - lon1)
        a = np.sin(dLat/2)**2 + np.cos(np.radians(lat1)) * np.cos(np.radians(lat2)) * np.sin(dLon/2)**2
        return R * 2 * np.arctan2(np.sqrt(a), np.sqrt(1-a))

    def detect_passenger_fraud(self):
        if len(self.passenger_stats) == 0: return pd.DataFrame()
        self.passenger_stats['fraud_probability'] = (
            (self.passenger_stats['cancellation_rate'] / self.fraud_thresholds['passenger_cancellation']).clip(0, 1) * 0.6 +
            (self.passenger_stats['avg_speed_kmh'] / self.fraud_thresholds['passenger_speed']).clip(0, 1) * 0.4
        )
        return self.passenger_stats.sort_values('fraud_probability', ascending=False).head(10)

    def detect_driver_fraud(self):
        if len(self.driver_stats) == 0: return pd.DataFrame()
        self.driver_stats['fraud_probability'] = (
            (self.driver_stats['status_changes'] / self.fraud_thresholds['driver_status_changes']).clip(0, 1) * 0.7 +
            (1 - self.driver_stats['vehicle_consistency']) * 0.3
        )
        return self.driver_stats.sort_values('fraud_probability', ascending=False).head(10)

    def generate_fraud_gauges(self):
        p_fraud = self.detect_passenger_fraud()
        d_fraud = self.detect_driver_fraud()
        avg_p = p_fraud['fraud_probability'].mean() if len(p_fraud) else 0
        avg_d = d_fraud['fraud_probability'].mean() if len(d_fraud) else 0

        fig = go.Figure()
        fig.add_trace(go.Indicator(mode="gauge+number", value=avg_p * 100, title={'text': "Passenger Fraud Risk"},
                                   domain={'row': 0, 'column': 0},
                                   gauge={'axis': {'range': [None, 100]}, 'bar': {'color': "darkblue"},
                                          'threshold': {'line': {'color': "red", 'width': 4}, 'value': 60}}))
        fig.add_trace(go.Indicator(mode="gauge+number", value=avg_d * 100, title={'text': "Driver Fraud Risk"},
                                   domain={'row': 0, 'column': 1},
                                   gauge={'axis': {'range': [None, 100]}, 'bar': {'color': "darkgreen"},
                                          'threshold': {'line': {'color': "red", 'width': 4}, 'value': 60}}))
        fig.update_layout(grid={'rows': 1, 'columns': 2, 'pattern': "independent"})
        return fig

    def generate_radar_charts(self):
        p_fig = go.Figure()
        d_fig = go.Figure()

        for df, fig, entity, metrics in [
            (self.detect_passenger_fraud(), p_fig, "Passenger", ['cancellation_rate', 'avg_speed_kmh', 'total_rides']),
            (self.detect_driver_fraud(), d_fig, "Driver", ['status_changes', 'availability_rate', 'vehicle_consistency'])
        ]:
            if len(df) == 0: continue
            for _, row in df.head(3).iterrows():
                fig.add_trace(go.Scatterpolar(
                    r=[row[m]/(row[m] if m != 'vehicle_consistency' else 1) for m in metrics],
                    theta=metrics,
                    fill='toself',
                    name=f"{entity} {row[entity.lower() + '_id'][:6]}"
                ))
            fig.update_layout(polar=dict(radialaxis=dict(visible=True, range=[0, 1])), showlegend=True,
                              title=f"{entity} Behavior Patterns")
        return p_fig, d_fig

# ----------------- STREAMLIT DASHBOARD -----------------
ACCOUNT_URL = "https://iesstsabdbaa.blob.core.windows.net/"
CONTAINER_NAME = "group7"
RIDE_PATH = "optimized_ride_data"
DRIVER_PATH = "optimized_driver_data"
ACCESS_KEY = "yfqMW8gf8u+M5pOW33Q5gtRTFBJQXStVK4K2rlCVVzxlrRG21Sh7MVj06uExoL86Npb7HWWgxYUe+ASthUr6/g=="
blob_service_client = BlobServiceClient(account_url=ACCOUNT_URL, credential=ACCESS_KEY)

def load_parquet_from_blob(path_prefix):
    container_client = blob_service_client.get_container_client(CONTAINER_NAME)
    blob_list = container_client.list_blobs(name_starts_with=path_prefix)
    dataframes = []
    for blob in blob_list:
        blob_client = container_client.get_blob_client(blob.name)
        stream = BytesIO(blob_client.download_blob().readall())
        try:
            df = pd.read_parquet(stream)
            dataframes.append(df)
        except:
            continue
    return pd.concat(dataframes, ignore_index=True) if dataframes else pd.DataFrame()

st.set_page_config(page_title="ðŸš– Real-Time Ride & Driver Dashboard", layout="wide")
st.title("ðŸš¦ Real-Time Ride & Driver Dashboard")

ride_df = load_parquet_from_blob(RIDE_PATH)
driver_df = load_parquet_from_blob(DRIVER_PATH)
ride_df.dropna(inplace=True)
driver_df.dropna(inplace=True)

if "datetime" in ride_df.columns:
    ride_df["datetime"] = pd.to_datetime(ride_df["datetime"])
if "pickup_time" in ride_df.columns and "dropoff_time" in ride_df.columns:
    ride_df["pickup_time"] = pd.to_datetime(ride_df["pickup_time"])
    ride_df["dropoff_time"] = pd.to_datetime(ride_df["dropoff_time"])
    ride_df["ride_duration_min"] = (ride_df["dropoff_time"] - ride_df["pickup_time"]).dt.total_seconds() / 60

fd = FraudDetection()
for _, row in ride_df.tail(500).iterrows():
    fd.add_ride_request(row)
for _, row in driver_df.tail(500).iterrows():
    fd.add_driver_status(row)

if not ride_df.empty:
    st.header("ðŸ“Š Basic Analytics")
    col1, col2, col3 = st.columns(3)
    col1.metric("Total Rides", len(ride_df))
    col2.metric("Completed Rides", len(ride_df[ride_df["status"] == "completed"]))
    col3.metric("Active Drivers", len(driver_df[driver_df["status"] == "active"]))

    st.subheader("Ride Status Distribution")
    pie_data = ride_df["status"].value_counts().reset_index()
    pie_data.columns = ["status", "count"]
    st.plotly_chart(px.pie(pie_data, names="status", values="count"))

    st.subheader("Ride Duration Distribution")
    st.plotly_chart(px.histogram(ride_df, x="ride_duration_min", nbins=30))

    st.subheader("Rides Over Time")
    rides_time = ride_df.set_index("datetime").resample("H").size().reset_index(name="ride_count")
    st.plotly_chart(px.line(rides_time, x="datetime", y="ride_count"))

    st.header("ðŸ§® Intermediate Analytics")
    cancellation_rate = len(ride_df[ride_df["status"] == "cancelled"]) / len(ride_df) * 100
    st.metric("Cancellation Rate", f"{cancellation_rate:.2f}%")

    demand = ride_df.set_index("datetime").resample("H").size().rename("ride_requests")
    demand_supply = demand.reset_index()
    demand_supply["active_drivers"] = len(driver_df[driver_df["status"] == "active"])
    st.plotly_chart(px.line(demand_supply, x="datetime", y=["ride_requests", "active_drivers"]))

    st.header("ðŸ§  Advanced Analytics")
    st.subheader("Fraud Risk Gauges")
    st.plotly_chart(fd.generate_fraud_gauges(), use_container_width=True)

    st.subheader("Behavioral Radar Charts")
    p_fig, d_fig = fd.generate_radar_charts()
    st.plotly_chart(p_fig, use_container_width=True)
    st.plotly_chart(d_fig, use_container_width=True)

if not driver_df.empty:
    st.header("ðŸš˜ Driver Analytics")
    status_data = driver_df["status"].value_counts().reset_index()
    status_data.columns = ["status", "count"]
    st.subheader("Driver Status Distribution")
    st.plotly_chart(px.pie(status_data, names="status", values="count"))

    vehicle_data = driver_df["vehicle_type"].value_counts().reset_index()
    vehicle_data.columns = ["vehicle_type", "count"]
    st.subheader("Vehicle Type Distribution")
    st.plotly_chart(px.bar(vehicle_data, x="vehicle_type", y="count"))